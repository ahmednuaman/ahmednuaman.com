title: Good ol' "Array.sortOn"
link: http://www.ahmednuaman.com/blog/good-ol-arraysorton/
creator: ahmed
description: 
post_id: 72
post_date: 2009-05-27 16:32:19
post_date_gmt: 2009-05-27 16:32:19
comment_status: open
post_name: good-ol-arraysorton
status: publish
post_type: post

# Good ol' "Array.sortOn"

I'm in the middle of creating a new [YouTube](http://youtube.com) gadget and part of the specification is that it allows the user to see the videos on a time-line. The idea behind it is that companies can then have a simple and sleek gadget that allows them to display their videos, whether they're viral or community influenced (much like [Sprite's Green Eyed World](http://www.youtube.com/greeneyedworld)), in a simple time-line sort of format. So using the MVC code I created for my other gadgets I was able to easily adapt it, create a new 2D carousel and then was left with the task of creating the visual time-line control and also sorting the videos by their date. Now the [YouTube GData API](http://code.google.com/apis/youtube/2.0/developers_guide_protocol_api_query_parameters.html) allows you to pass a parameter called "[orderby](http://code.google.com/apis/youtube/2.0/developers_guide_protocol_api_query_parameters.html#orderbysp)" with the value "published" which returns the entries according to when they were uploaded, the latest first. That's all good, but I want to have the earliest first, so I could just do "[Array.reverse()](http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/Array.html#reverse())" you say? Well yes I could but what about [playlists](http://code.google.com/apis/youtube/2.0/developers_guide_protocol_playlists.html)? All GData feeds return Atom formatted XML, so that means my gadget can retrieve a playlist, a search query, or a user's videos, etc... So making it scalable is the best option. Since playlists can be sorted by the user, you can't pass the "orderby" parameter and expect it to work. Instead you need to go through the XML data and sort the entries according to their "uploaded" values. So the first thing to do is to get the epoch time-stamp of the uploaded date and time, simply use the [AS3CoreLib](http://code.google.com/p/as3corelib/) like this: ` var timestamp:Number = DateUtil.parseW3CDTF( entry..*::uploaded.toString() ).valueOf(); ` So once we have the value of the uploaded date and time, we can then push this into a nice array of objects and use the "[Array.sortOn()](http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/Array.html#sortOn())" function to sort our entries according to their dates: ` var cleanData:Array = [ ]; for each ( var entry:XML in data..*::entry ) { cleanData.push({ title: entry.*::title, videoId: entry..*::videoid.toString(), uploaded: DateUtil.parseW3CDTF( entry..*::uploaded.toString() ).valueOf() }); } cleanData.sortOn( 'uploaded', Array.NUMERIC ); ` This will then return the videos order chronologically with the earliest at the start. If you want the latest at the start, you can then stick the array through "Array.reverse()"