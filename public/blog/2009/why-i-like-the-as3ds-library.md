title: Why I like the AS3DS Library
link: http://www.ahmednuaman.com/blog/why-i-like-the-as3ds-library/
creator: ahmed
description: 
post_id: 197
post_date: 2009-06-23 11:32:08
post_date_gmt: 2009-06-23 11:32:08
comment_status: open
post_name: why-i-like-the-as3ds-library
status: publish
post_type: post

# Why I like the AS3DS Library

This is a quick article about why I like the [AS3 Data Structures For Game Developers](http://code.google.com/p/as3ds/). I first came across this library when I was looking at effective ways of making carousels, for example, the current [carousel on my portfolio](/index.php) uses the library. I'm probably not using it to its full potential, but it's very good for what I am using it for. Imagine the situation: you want to create a carousel (much like the [carousel on my portfolio](/index.php)) where by you are loading in images, moving them from the right to the left and then allowing the user to flick through them too. The way most people do this is by using arrays to store the references to the display items and cycling through them, like so: ` package { import flash.display.Graphics; import flash.display.Sprite; import flash.utils.setTimeout; import gs.TweenLite; import gs.easing.Strong; [SWF( width="580", height="400", frameRate="30", backgroundColor="#FFFFFF" )] public class App extends Sprite { private var boxes:Array = [ ]; private var current:Number = 0; private var stageHeight:Number = 400; private var stageWidth:Number = 580; public function App() { for ( var i:Number = 0; i < 20; i++ ) { drawBox(); } start(); } private function drawBox():void { var box:Sprite = new Sprite(); var graphics:Graphics = box.graphics; var colour:uint = Math.random() * 0xFFFFFF; graphics.beginFill( colour ); graphics.drawRoundRect( 0, 0, stageWidth, stageHeight, 3, 3 ); graphics.endFill(); boxes.push( box ); addChild( box ); } private function start():void { var target:Sprite; for ( var i:Number = 0; i < boxes.length; i++ ) { target = boxes[ i ]; if ( i < current ) { TweenLite.to( target, 1, { x: -stageWidth, ease: Strong.easeOut } ); } else if ( i == current ) { setChildIndex( target, numChildren - 1 ); TweenLite.to( target, 1, { x: 0, ease: Strong.easeOut } ); } else { target.x = stageWidth; } } if ( current >= boxes.length - 1 ) { current = 0; } else { current++; } setTimeout( start, 2000 ); } } } ` Here's what the code does: 

[kml_flashembed publishmethod="static" fversion="9.0.0" useexpressinstall="true" movie="/_/dev/as3ds/1.swf" width="580" height="400" targetclass="flashmovie"]

And that works pretty nicely, whereby I'm cycling through the array and then showing one and hiding the others. Looks fairly standard, but with the [as3ds](http://code.google.com/p/as3ds/) library, it can be simplified to this: ` package { import de.polygonal.ds.DLinkedList; import de.polygonal.ds.DListNode; import flash.display.Graphics; import flash.display.Sprite; import flash.utils.setTimeout; import gs.TweenLite; import gs.easing.Strong; [SWF( width="580", height="400", frameRate="30", backgroundColor="#FFFFFF" )] public class App2 extends Sprite { private var boxes:DLinkedList = new DLinkedList(); private var stageHeight:Number = 400; private var stageWidth:Number = 580; private var current:DListNode; public function App2() { for ( var i:Number = 0; i < 20; i++ ) { drawBox(); } current = boxes.head; start(); } private function drawBox():void { var box:Sprite = new Sprite(); var graphics:Graphics = box.graphics; var colour:uint = Math.random() * 0xFFFFFF; graphics.beginFill( colour ); graphics.drawRoundRect( 0, 0, stageWidth, stageHeight, 3, 3 ); graphics.endFill(); boxes.append( box ); addChild( box ); } private function start():void { var nodePrev:DListNode = current.prev; var nodeNext:DListNode = current.next; var target:Sprite = current.data as Sprite; setChildIndex( target, numChildren - 1 ); TweenLite.to( target, 1, { x: 0, ease: Strong.easeOut } ); while ( nodePrev ) { TweenLite.to( nodePrev.data as Sprite, 1, { x: -stageWidth, ease: Strong.easeOut } ); nodePrev = nodePrev.prev; } while ( nodeNext ) { ( nodeNext.data as Sprite ).x = stageWidth; nodeNext = nodeNext.next; } current = ( current.next ? current.next : boxes.head ); setTimeout( start, 2000 ); } } } ` You can see I've replaced the array with the "DLinkedList()" class. This, kind of like [dictionaries](http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/flash/utils/Dictionary.html), allows you to put anything in there, but the class comes with the great get functions such as "DLinkedList.prev" and "DLinkedList.next" that allow you to get the previous and next entries, much easier than incrementing. And here's what you get, it's pretty identical, but I think that using the AS3DS class makes handling visual elements, well any elements, where looping functionality is needed or the ability to cycle through lists, much easier. 

[kml_flashembed publishmethod="static" fversion="9.0.0" useexpressinstall="true" movie="/_/dev/as3ds/2.swf" width="580" height="400" targetclass="flashmovie"]

Tell me what you think.`